/*
    Functions of this library return the maximum argument

    Syntax:   #include "max_lib.h"
    
              Max(int)
              Max(int, int)
              Max(int, int, int)
              Max(double, double)
              Max(char, char)
              Max(string, string)
              Max(vector<int>)
*/

#include<iostream>
#include<string>
#include<vector>

using namespace std;

int Max(int a) { 
    return a; 
}

int Max(int a, int b) { 
    return (a > b) ? a : b; 
}

int Max(int a, int b, int c) {
  if (a >= b && a >= c) {
    return a;
  } else if (b >= a && b >= c) {
    return b;
  } else {
    return c;
  }
}

double Max(double a, double b) { 
    return (a > b) ? a : b; 
}

char Max(char a, char b) { 
    return (a > b) ? a : b; 
}

string Max(string a, string b) { 
    return (a > b) ? a : b; 
}

int Max(vector<int> a) {
  int max = a[0];
  for (int i = 1; i < a.size(); i++) {
    if (a[i] > max) {
      max = a[i];
    }
  }
  return max;
}

1)Перегрузка функций. 

В процессе написания кода часто возникают различные проблемы. Например, если мы имеем две или более функций, которые имеют похожую логику, нам бы хотелось каким-либо образом объединить их, чтобы не использовать разные имена. Специально для этого в языке C++ предусмотрена возможность перегрузки функций. Перегруженные функции могут иметь разные типы возвращаемого значения, разное количество аргументов. Таким образом, перегруженные функции имеют одинаковое имя, но разную сигнатуру. 

 

Рассмотрим пример:  

У нас есть программа, при написании которой у нас возникла необходимость определять максимум из двух целых и из двух дробных чисел. Так как у нас только 2 типа возвращаемых значений, выгоднее будет использовать именно перегрузку функция, а не шаблон. 

Так будет выглядеть функция для целых чисел. 

int Max(int a, int b) {  

    return (a > b) ? a : b;  

} 

А так для дробных. 

double Max(double a, double b) {  

    return (a > b) ? a : b;  

} 

Таким образом, теперь мы можем в любой момент вызывать функцию Max и не задумываться о типе аргументов. 

 

2)UML. Диаграмма классов, отношение между классами. Примеры реализаций с кодом 

Очень часто в процессе написания кода, особенно если используется наследование, возникает необходимость графически представить все элементы.  В таких случаях можно использовать UML - специальный унифицированный язык и использовать его при построении диаграмм. Главную роль в UML играют сущности - абстракции, на основе которых и создаются диаграммы. 